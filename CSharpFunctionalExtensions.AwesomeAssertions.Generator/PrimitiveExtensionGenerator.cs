using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace CSharpFunctionalExtensions.AwesomeAssertions.Generator;

[Generator]
public class PrimitiveExtensionGenerator : IIncrementalGenerator
{
    private const string AttributeNamespace = "CSharpFunctionalExtensions.AwesomeAssertions.Generator";
    private const string AttributeName = "GeneratePrimitiveExtensionsAttribute";
    private const string AttributeFullName = $"{AttributeNamespace}.{AttributeName}";

    // The attribute source code with an explicit type specification
    private const string AttributeSourceCode = @"// <auto-generated/>
using System;
using System.Diagnostics.CodeAnalysis;
using System.Diagnostics;

[DebuggerNonUserCode]
[ExcludeFromCodeCoverage]
namespace CSharpFunctionalExtensions.AwesomeAssertions.Generator
{
    /// <summary>
    /// Marks a class for the generation of primitive assertion extensions.
    /// </summary>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
    public class GeneratePrimitiveExtensionsAttribute : Attribute
    {
        /// <summary>
        /// Gets the name of the methods to generate.
        /// </summary>
        public string MethodName { get; }

        /// <summary>
        /// Gets the field or property accessor to use.
        /// </summary>
        public string FieldAccessor { get; }

        /// <summary>
        /// Gets the fully qualified target type name including namespace.
        /// </summary>
        public string TargetTypeName { get; }

        /// <summary>
        /// Gets which generic parameter to use for the assertion type (0 for left/first, 1 for right/second).
        /// </summary>
        public int GenericPosition { get; }

        /// <summary>
        /// Initializes a new instance of the <see cref=""GeneratePrimitiveExtensionsAttribute""/> class.
        /// </summary>
        /// <param name=""methodName"">The name of the methods to generate.</param>
        /// <param name=""fieldAccessor"">The field or property accessor to use.</param>
        /// <param name=""targetTypeName"">The fully qualified target type name (e.g. ""CSharpFunctionalExtensions.Result`2"").</param>
        /// <param name=""genericPosition"">Which generic parameter to use (0 for left/first, 1 for right/second).</param>
        public GeneratePrimitiveExtensionsAttribute(string methodName, string fieldAccessor, string targetTypeName, int genericPosition = 0)
        {
            MethodName = methodName;
            FieldAccessor = fieldAccessor;
            TargetTypeName = targetTypeName;
            GenericPosition = genericPosition;
        }
    }
}";

    // List of primitive types to generate assertions for
    private static readonly List<(string TypeName, string AssertionType)> _primitiveTypes =
    [
        ("string", "String"),
        ("bool", "Boolean"),
        ("bool?", "NullableBoolean"),
        ("DateOnly", "DateOnly"),
        ("DateOnly?", "NullableDateOnly"),
        ("TimeOnly", "TimeOnly"),
        ("TimeOnly?", "NullableTimeOnly"),
        ("DateTime", "DateTime"),
        ("DateTime?", "NullableDateTime"),
        ("DateTimeOffset", "DateTimeOffset"),
        ("DateTimeOffset?", "NullableDateTimeOffset"),
        ("Guid", "Guid"),
        ("Guid?", "NullableGuid"),
        ("TimeSpan", "SimpleTimeSpan"),
        ("TimeSpan?", "NullableSimpleTimeSpan"),
        ("Type", "Type"),
        ("MethodInfo", "MethodInfo"),
        ("PropertyInfo", "PropertyInfo"),
        ("object", "Object")
    ];

    // list of primitive with generic assertion types
    private static readonly HashSet<(string TypeName, string AssertionType, string AssertionGenericTypeName, string?
            genericCounpound)>
        _genericPrimitiveTypes =
        [
            ("int", "Numeric", "int", null),
            ("int?", "NullableNumeric", "int", null),
            ("long", "Numeric", "long", null),
            ("long?", "NullableNumeric", "long", null),
            ("short", "Numeric", "short", null),
            ("short?", "NullableNumeric", "short", null),
            ("ushort", "Numeric", "ushort", null),
            ("ushort?", "NullableNumeric", "ushort", null),
            ("byte", "Numeric", "byte", null),
            ("byte?", "NullableNumeric", "byte", null),
            ("sbyte", "Numeric", "sbyte", null),
            ("sbyte?", "NullableNumeric", "sbyte", null),
            ("char", "Numeric", "char", null),
            ("char?", "NullableNumeric", "char", null),
            ("uint", "Numeric", "uint", null),
            ("uint?", "NullableNumeric", "uint", null),
            ("ulong", "Numeric", "ulong", null),
            ("ulong?", "NullableNumeric", "ulong", null),
            ("float", "Numeric", "float", null),
            ("float?", "NullableNumeric", "float", null),
            ("double", "Numeric", "double", null),
            ("double?", "NullableNumeric", "double", null),
            ("decimal", "Numeric", "decimal", null),
            ("decimal?", "NullableNumeric", "decimal", null),
            ("IEnumerable<U>", "GenericCollection", "U", "U"),
            ("IList<U>", "GenericCollection", "U", "U"),
            ("ICollection<U>", "GenericCollection", "U", "U"),
            ("IReadOnlyList<U>", "GenericCollection", "U", "U"),
            ("IReadOnlyCollection<U>", "GenericCollection", "U", "U"),
            ("ReadOnlyCollection<U>", "GenericCollection", "U", "U"),
            ("List<U>", "GenericCollection", "U", "U"),
            ("U[]", "GenericCollection", "U", "U"),
            ("ArraySegment<U>", "GenericCollection", "U", "U")
        ];

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register the attribute source
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Get classes with our attribute
        var classesWithAttribute = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: (s, _) => s is ClassDeclarationSyntax { AttributeLists.Count: > 0 },
                transform: (ctx, _) => GetClassWithAttribute(ctx))
            .Where(result => result.attributeData.Count > 0)
            .Select((result, _) => result);

        // Combine with compilation
        var compilationAndClasses = context.CompilationProvider.Combine(classesWithAttribute.Collect());

        // Register source output
        context.RegisterSourceOutput(compilationAndClasses,
            (spc, source) => GenerateExtensions(spc, source.Left, source.Right!));
    }

    private static (INamedTypeSymbol? classSymbol, List<AttributeData> attributeData) GetClassWithAttribute(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var semanticModel = context.SemanticModel;

        // Get symbol for this class
        if (semanticModel.GetDeclaredSymbol(classDeclarationSyntax) is not { } classSymbol)
            return (null, []);

        // Find our attribute on this class
        var attributes = classSymbol.GetAttributes()
            .Where(a => a.AttributeClass?.ToDisplayString() == AttributeFullName)
            .ToList();

        return (classSymbol, attributes);
    }

    private static void GenerateExtensions(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<(INamedTypeSymbol classSymbol, List<AttributeData> attributeData)> classesWithAttributes)
    {
        if (classesWithAttributes.IsDefaultOrEmpty)
        {
            context.AddSource("Debug_NoClassesFound.g.cs",
                SourceText.From("// No classes with the GeneratePrimitiveExtensionsAttribute were found",
                    Encoding.UTF8));
            return;
        }

        var sourceBuilder = new StringBuilder();
        WriteFileHeader(sourceBuilder);

        foreach (var (classSymbol, attributeDataList) in classesWithAttributes)
        foreach (var attributeData in attributeDataList)
        {
            context.CancellationToken.ThrowIfCancellationRequested();
            GenerateExtensionsForClass(sourceBuilder, compilation, classSymbol, attributeData, context);
        }

        WriteFileFooter(sourceBuilder);
        context.AddSource("GeneratedExtensions.g.cs", SourceText.From(sourceBuilder.ToString(), Encoding.UTF8));
    }

    private static void WriteFileHeader(StringBuilder sb)
        => sb.AppendLine("""
                         // <auto-generated/>
                         using System;
                         using System.Collections;
                         using System.Collections.Generic;
                         using System.Collections.ObjectModel;
                         using System.Diagnostics;
                         using System.Diagnostics.CodeAnalysis;
                         using System.IO;
                         using System.Linq.Expressions;
                         using System.Reflection;
                         using System.Threading.Tasks;
                         using System.Xml.Linq;
                         using FluentAssertions.Collections;
                         using FluentAssertions.Common;
                         using FluentAssertions.Execution;
                         using FluentAssertions.Numeric;
                         using FluentAssertions.Primitives;
                         using FluentAssertions.Specialized;
                         using FluentAssertions.Streams;
                         using FluentAssertions.Types;
                         using FluentAssertions.Xml;
                         using NotNullAttribute = System.Diagnostics.CodeAnalysis.NotNullAttribute;

                         // ReSharper disable once CheckNamespace
                         namespace FluentAssertions
                         {
                             [DebuggerNonUserCode]
                             public static partial class GeneratedExtensions
                             {
                         """);

    private static void WriteFileFooter(StringBuilder sb)
        => sb.AppendLine("""
                             }
                         }
                         """);


    private static void GenerateExtensionsForClass(
        StringBuilder sb,
        Compilation compilation,
        INamedTypeSymbol classSymbol,
        AttributeData attributeData,
        SourceProductionContext context)
    {
        // Extract attribute values
        var methodName = GetAttributeStringValue(attributeData, "MethodName")
                         ?? throw new InvalidOperationException("MethodName is required");
        var fieldAccessor = GetAttributeStringValue(attributeData, "FieldAccessor")
                            ?? throw new InvalidOperationException("FieldAccessor is required");
        var genericPosition = GetAttributeIntValue(attributeData, "GenericPosition");
        var targetTypeName = GetAttributeStringValue(attributeData, "TargetTypeName")
                             ?? throw new InvalidOperationException("TargetTypeName is required");

        var targetType = compilation.GetTypeByMetadataName(targetTypeName);
        if (targetType == null)
        {
            context.AddSource($"Debug_{classSymbol.Name}_{targetTypeName}_{genericPosition}TypeNotFound.g.cs",
                SourceText.From($"// Type not found: {targetTypeName}", Encoding.UTF8));
            return;
        }

        context.AddSource($"Debug_{classSymbol.Name}_{targetTypeName}_{genericPosition}TypeFound.g.cs",
            SourceText.From($"// Type found: {targetTypeName}", Encoding.UTF8));

        // Extract type information
        var className = targetType.Name;
        var fullTypeName = targetType.ToDisplayString(new SymbolDisplayFormat(
            typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces,
            genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters));

        var typeParameters = targetType.TypeParameters;
        var typeParamsDecl = typeParameters.Length > 0
            ? $"<{string.Join(", ", typeParameters.Select(x => x.Name))}>"
            : "";

        // Generate extension methods
        if (typeParameters.Length > 0)
        {
            GeneratePrimitiveExtensions(sb, className, fullTypeName, typeParameters, typeParamsDecl, methodName,
                fieldAccessor, genericPosition);
            GenerateGenericPrimitiveExtensions(sb, className, fullTypeName, typeParameters, typeParamsDecl, methodName,
                fieldAccessor, genericPosition);
            GenerateEnumExtensions(sb, className, fullTypeName, typeParameters, typeParamsDecl, methodName,
                fieldAccessor, genericPosition);
        }
        else
        {
            context.AddSource($"Debug_{classSymbol.Name}_NonGeneric.g.cs",
                SourceText.From($"// Class {className} is not generic, no extensions generated", Encoding.UTF8));
        }
    }

    private static string? GetAttributeStringValue(AttributeData attributeData, string propertyName)
    {
        // First check named arguments
        var namedArgument = attributeData.NamedArguments.FirstOrDefault(na => na.Key == propertyName);
        if (!namedArgument.Equals(null) && namedArgument.Value.Value is string stringValue)
            return stringValue;

        return propertyName switch
        {
            // Then check constructor arguments by position
            "MethodName" when attributeData.ConstructorArguments.Length > 0 &&
                              attributeData.ConstructorArguments[0].Value is string methodName => methodName,
            "FieldAccessor" when attributeData.ConstructorArguments.Length > 1 &&
                                 attributeData.ConstructorArguments[1].Value is string fieldAccessor => fieldAccessor,
            "TargetTypeName" when attributeData.ConstructorArguments.Length > 2 &&
                                  attributeData.ConstructorArguments[2].Kind == TypedConstantKind.Primitive &&
                                  attributeData.ConstructorArguments[2].Value is string typeName => typeName,
            _ => null
        };
    }

    private static int GetAttributeIntValue(AttributeData attributeData, string propertyName)
    {
        // First check named arguments
        var namedArgument = attributeData.NamedArguments.FirstOrDefault(na => na.Key == propertyName);
        if (!namedArgument.Equals(default) && namedArgument.Value.Value is int intValue)
            return intValue;

        // Then check constructor arguments by position
        if (propertyName == "GenericPosition" && attributeData.ConstructorArguments.Length > 3
                                              && attributeData.ConstructorArguments[3].Value is int position)
            return position;

        // Default for GenericPosition
        return 0;
    }

    private static void GeneratePrimitiveExtensions(
        StringBuilder sb, string className, string fullTypeName,
        IReadOnlyList<ITypeParameterSymbol> typeParameters,
        string typeParamsDecl, string methodName, string fieldAccessor,
        int genericPosition)
    {
        // Generate methods for all primitive types
        foreach (var (typeName, assertionType) in _primitiveTypes)
            sb.Append(typeParameters.Count switch
            {
                1 => $"""

                              /// <summary>
                              /// Assertion extension for {typeName} values.
                              /// </summary>
                              public static {assertionType}Assertions {methodName}(this {fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeName}>")} instance)
                                  => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());
                                  
                      """,
                2 => (typeParameters[0].Name, typeParameters[1].Name) switch
                {
                    var (_, typeParam2) when genericPosition == 0 =>
                        $"""

                                 /// <summary>
                                 /// Assertion extension for {typeName} values.
                                 /// </summary>
                                 public static {assertionType}Assertions {methodName}<{typeParam2}>(this {fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeName}, {typeParam2}>")} instance)
                                     => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());
                                     
                         """,
                    var (typeParam1, _) when genericPosition == 1 =>
                        $"""

                                 /// <summary>
                                 /// Assertion extension for {typeName} values.
                                 /// </summary>
                                 public static {assertionType}Assertions {methodName}<{typeParam1}>(this {fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeParam1}, {typeName}>")} instance)
                                     => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());
                                     
                         """,
                    _ => throw new InvalidOperationException($"Invalid generic position: {genericPosition}")
                },
                _ => throw new InvalidOperationException($"Invalid number of type parameters: {typeParameters.Count}")
            });
    }

    private static void GenerateEnumExtensions(
        StringBuilder sb, string className, string fullTypeName, IReadOnlyList<ITypeParameterSymbol> typeParameters,
        string typeParamsDecl, string methodName, string fieldAccessor, int genericPosition)
        => sb.Append(typeParameters.Count switch
        {
            1 => $"""

                          /// <summary>
                          /// Assertion extension for enum values, TIgnored is to keep compatibility with the IComparable Numeric type generic overload.
                          /// </summary>
                          public static EnumAssertions<TEnum> {methodName}<TEnum, TIgnored>(this {fullTypeName.Replace(className + typeParamsDecl, className + "<TEnum>")} instance)
                              where TEnum : struct, Enum
                              => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());

                          /// <summary>
                          /// Assertion extension for nullable enum values, TIgnored is to keep compatibility with the IComparable Numeric type generic overload.
                          /// </summary>
                          public static NullableEnumAssertions<TEnum> {methodName}<TEnum, TIgnored>(this {fullTypeName.Replace(className + typeParamsDecl, className + "<TEnum?>")} instance)
                              where TEnum : struct, Enum
                              => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());
                              
                  """,
            2 => (typeParameters[0].Name, typeParameters[1].Name) switch
            {
                var (_, typeParam2) when genericPosition == 0 =>
                    $"""

                             /// <summary>
                             /// Assertion extension for enum values, TIgnored is to keep compatibility with the IComparable Numeric type generic overload.
                             /// </summary>
                             public static EnumAssertions<TEnum> {methodName}<TEnum, {typeParam2}, TIgnored>(this {fullTypeName.Replace(className + typeParamsDecl, className + $"<TEnum, {typeParam2}>")} instance)
                                 where TEnum : struct, Enum
                                 => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());

                             /// <summary>
                             /// Assertion extension for nullable enum values, TIgnored is to keep compatibility with the IComparable Numeric type generic overload.
                             /// </summary>
                             public static NullableEnumAssertions<TEnum> {methodName}<TEnum, {typeParam2}, TIgnored>(this {fullTypeName.Replace(className + typeParamsDecl, className + $"<TEnum?, {typeParam2}>")} instance)
                                 where TEnum : struct, Enum
                                 => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());
                                 
                     """,
                var (typeParam1, _) when genericPosition == 1 =>
                    $"""

                             /// <summary>
                             /// Assertion extension for enum values, TIgnored is to keep compatibility with the IComparable Numeric type generic overload.
                             /// </summary>
                             public static EnumAssertions<TEnum> {methodName}<{typeParam1}, TEnum, TIgnored>(this {fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeParam1}, TEnum>")} instance)
                                 where TEnum : struct, Enum
                                 => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());

                             /// <summary>
                             /// Assertion extension for nullable enum values, TIgnored is to keep compatibility with the IComparable Numeric type generic overload.
                             /// </summary>
                             public static NullableEnumAssertions<TEnum> {methodName}<{typeParam1}, TEnum, TIgnored>(this {fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeParam1}, TEnum?>")} instance)
                                 where TEnum : struct, Enum
                                 => new(instance.{fieldAccessor}, AssertionChain.GetOrCreate());
                                 
                     """,
                _ => throw new InvalidOperationException($"Invalid generic position: {genericPosition}")
            },
            _ => throw new InvalidOperationException($"Invalid number of type parameters: {typeParameters.Count}")
        });

    private static void GenerateGenericPrimitiveExtensions(
        StringBuilder sb, string className, string fullTypeName,
        IReadOnlyList<ITypeParameterSymbol> typeParameters,
        string typeParamsDecl, string methodName, string fieldAccessor,
        int genericPosition)
    {
        foreach (var (typeName, assertionType, assertionGenericTypeName, genericCounpound) in _genericPrimitiveTypes)
            sb.Append(typeParameters.Count switch
            {
                1 => $$"""

                               /// <summary>
                               /// Assertion extension for {{typeName}} values.
                               /// </summary>
                               public static {{assertionType}}Assertions<{{assertionGenericTypeName}}> {{methodName}}{{(genericCounpound is null ? "" : $"<{genericCounpound}>")}}(this {{fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeName}>")}} instance)
                                   => new(instance.{{fieldAccessor}}, AssertionChain.GetOrCreate());
                                   
                       """,
                2 => (typeParameters[0].Name, typeParameters[1].Name) switch
                {
                    var (_, typeParam2) when genericPosition == 0 =>
                        $$"""

                                  /// <summary>
                                  /// Assertion extension for {{typeName}} values.
                                  /// </summary>
                                  public static {{assertionType}}Assertions<{{assertionGenericTypeName}}> {{methodName}}<{{typeParam2}}{{(genericCounpound is null ? "" : $", {genericCounpound}")}}>(this {{fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeName}, {typeParam2}>")}} instance)
                                      => new(instance.{{fieldAccessor}}, AssertionChain.GetOrCreate());
                                      
                          """,
                    var (typeParam1, _) when genericPosition == 1 =>
                        $$"""

                                  /// <summary>
                                  /// Assertion extension for {{typeName}} values.
                                  /// </summary>
                                  public static {{assertionType}}Assertions<{{assertionGenericTypeName}}> {{methodName}}<{{typeParam1}}{{(genericCounpound is null ? "" : $", {genericCounpound}")}}>(this {{fullTypeName.Replace(className + typeParamsDecl, className + $"<{typeParam1}, {typeName}>")}} instance)
                                      => new(instance.{{fieldAccessor}}, AssertionChain.GetOrCreate());
                                      
                          """,
                    _ => throw new InvalidOperationException($"Invalid generic position: {genericPosition}")
                },
                _ => throw new InvalidOperationException($"Invalid number of type parameters: {typeParameters.Count}")
            });
    }
}